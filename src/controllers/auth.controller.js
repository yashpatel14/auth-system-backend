import { asyncHandler } from "../utils/asyncHandler.js";
import { ApiResponse } from "../utils/ApiResponse.js";
import { ApiError } from "../utils/ApiError.js";
import { User } from "../models/auth.model.js";
import { handleZodError } from "../utils/handleZodError.js";
import {
  validateEmail,
  validateLogin,
  validateRegister,
  validateResetPassword,
} from "../validations/auth.validation.js";
import { uploadOnCloudinary } from "../utils/cloudinary.js";
import { emailVerificationMailgenContent, sendEmail } from "../utils/mail.js";
import { Session } from "../models/session.model.js";
import { transformSessions } from "../utils/transfromSessions.js";
import { logger } from "../configs/logger.js";
import crypto from "crypto";
import ms from "ms";

const generateAccessAndRefreshTokens = async (userId) => {
  try {
    const user = await User.findById(userId);

    const accessToken = user.generateAccessToken();
    const refreshToken = user.generateRefreshToken();

    // attach refresh token to the user document to avoid refreshing the access token with multiple refresh tokens
    user.refreshToken = refreshToken;

    await user.save({ validateBeforeSave: false });
    return { accessToken, refreshToken };
  } catch (error) {
    throw new ApiError(
      500,
      "Something went wrong while generating the access token"
    );
  }
};

const register = asyncHandler(async (req, res, next) => {
  const { fullname, email, password } = handleZodError(
    validateRegister(req.body)
  );

  logger.info("Registration attempt", { email, ip: req.ip });

  const exitingUser = await User.findOne({ email });

  if (exitingUser) {
    throw new ApiError(409, "User already exist with this email address");
  }

  let avatarUrl;
  if (req.file) {
    try {
      const uploaded = await uploadOnCloudinary(req.file.path);
      avatarUrl = uploaded?.secure_url;
      logger.info("Avatar uploaded successfully", { email, avatarUrl });
    } catch (err) {
      logger.warn(`Avatar upload failed for ${email} due to ${err.message}`);
    }
  }

  const user = await User.create({
    fullname,
    email,
    password,
    avatar: avatarUrl,
  });

  const { unHashedToken, hashedToken, tokenExpiry } =
    user.generateTemporaryToken();

  /**
   * assign hashedToken and tokenExpiry in DB till user clicks on email verification link
   * The email verification is handled by {@link verifyEmail}
   */
  user.emailVerificationToken = hashedToken;
  user.emailVerificationExpiry = tokenExpiry;
  await user.save({ validateBeforeSave: false });

  await sendEmail({
    email: user?.email,
    subject: "Please verify your email",
    mailgenContent: emailVerificationMailgenContent(
      user.username,
      `${process.env.CLIENT_URL}/verify-email/${unHashedToken}`
    ),
  });

  logger.info("Verification email sent", {
    email,
    userId: user.id,
    ip: req.ip,
  });

  logger.info("User registered successfully", {
    email,
    userId: user.id,
    ip: req.ip,
  });

  const createdUser = await User.findById(user._id).select(
    "-password -emailVerificationToken -emailVerificationExpiry"
  );

  if (!createdUser) {
    throw new ApiError(500, "Something went wrong while registering the user");
  }

  return res
    .status(201)
    .json(
      new ApiResponse(
        201,
        { user: createdUser },
        "Users registered successfully and verification email has been sent on your email."
      )
    );
});

const verifyEmail = asyncHandler(async (req, res) => {
  const { token } = req.params;

  if (!token) {
    throw new ApiError(400, "Email verification token is missing");
  }

  // generate a hash from the token that we are receiving

  let hashedToken = crypto.createHash("sha256").update(token).digest("hex");

  console.log(token);

  // While registering the user, same time when we are sending the verification mail
  // we have saved a hashed value of the original email verification token in the db
  // We will try to find user with the hashed token generated by received token
  // If we find the user another check is if token expiry of that token is greater than current time if not that means it is expired
  const user = await User.findOne({
    emailVerificationToken: hashedToken,
    emailVerificationExpiry: { $gt: Date.now() },
  });

  console.log("User found:", user);

  console.log("Incoming raw token:", token);
  console.log("Hashed token:", hashedToken);

  if (!user) {
    throw new ApiError(489, "Token is invalid or expired");
  }

  const { accessToken, refreshToken } = await generateAccessAndRefreshTokens(
    user._id
  );

  const hashedRefreshToken = user.createHash(refreshToken);

  const expiresAt = new Date(Date.now() + ms(process.env.REFRESH_TOKEN_EXPIRY));

  // If we found the user that means the token is valid
  // Now we can remove the associated email token and expiry date as we no  longer need them
  user.emailVerificationToken = undefined;
  user.emailVerificationExpiry = undefined;
  // Turn the email verified flag to `true`
  user.isEmailVerified = true;
  await user.save({ validateBeforeSave: false });

  const session = await Session.create({
    userId: user._id,
    userAgent: req.headers["user-agent"],
    ipAddress: req.ip,
    refreshToken: hashedRefreshToken,
    expiresAt,
  });

  logger.info("Email verified successfully", {
    email: user.email,
    userId: user._id,
    ip: req.ip,
  });

  const rememberMe = req.body?.rememberMe || false;
  const expiry = rememberMe
    ? process.env.REFRESH_TOKEN_EXPIRY_REMEMBER_ME
    : process.env.REFRESH_TOKEN_EXPIRY;

  const options = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: ms(expiry),
  };

  res
    .status(200)
    .cookie("accessToken", accessToken, options)
    .cookie("refreshToken", refreshToken, options)
    .json(new ApiResponse(200, null, "Email verified successfully"));
});

const resendEmailVerification = asyncHandler(async (req, res) => {
  const { email } = handleZodError(validateEmail(req.body));
  const user = await User.findOne({ email });

  if (!user) {
    throw new ApiError(404, "User does not exists", []);
  }

  // if email is already verified throw an error
  if (user.isEmailVerified) {
    throw new ApiError(409, "Email is already verified!");
  }

  const { unHashedToken, hashedToken, tokenExpiry } =
    user.generateTemporaryToken(); // generate email verification creds

  user.emailVerificationToken = hashedToken;
  user.emailVerificationExpiry = tokenExpiry;
  await user.save({ validateBeforeSave: false });

  await sendEmail({
    email: user?.email,
    subject: "Please verify your email",
    mailgenContent: emailVerificationMailgenContent(
      user.username,
      `${process.env.CLIENT_URL}/verify-email/${unHashedToken}`
    ),
  });

  logger.info(`Verification email resent`, {
    email,
    userId: user.id,
    ip: req.ip,
  });

  return res
    .status(200)
    .json(new ApiResponse(200, {}, "Mail has been sent to your mail ID"));
});

const login = asyncHandler(async (req, res) => {
  const { email, password, rememberMe } = handleZodError(
    validateLogin(req.body)
  );

  const user = await User.findOne({ email });

  if (!user) {
    throw new ApiError(401, "User does not exists");
  }

  const isPasswordCorrect = await user.isPasswordCorrect(password, user.password);

  if (!isPasswordCorrect) {
    throw new ApiError(401, "Password is incorrect");
  }

  if (!user.isEmailVerified) {
    throw new ApiError(401, "Email is not verified");
  }

  const userAgent = req.headers["user-agent"];
  const ipAddress = req.ip;

  const existingSession = await Session.findOne({
    userId: user.id,
    userAgent,
    ipAddress,
  });

  const existingSessionsCountResult = await Session.aggregate([
    { $match: { userId: user._id } },
    { $count: "count" },
  ]);
  
  const existingSessionsCount = existingSessionsCountResult[0]?.count || 0;

  if (!existingSession && existingSessionsCount >= parseInt(process.env.MAX_SESSIONS)) {
  throw new ApiError(
    429,
    "Maximum session limit reached. Please logout from another device first."
  );
}


  const { accessToken, refreshToken } = await generateAccessAndRefreshTokens(
    user._id
  );

  const hashedRefreshToken = user.createHash(refreshToken);

  const expiresAt = new Date(Date.now() + ms(process.env.REFRESH_TOKEN_EXPIRY));

  if (existingSession) {
    // if session already exists update refresh token and expiry time
    await Session.updateOne(
      { _id: existingSession._id }, // if `id` is ObjectId
      {
        $set: {
          refreshToken: hashedRefreshToken,
          expiresAt: expiresAt,
        },
      }
    );
  } else {
    // otherwise create a new session
    await Session.create({
      userId: user._id,
      userAgent: userAgent,
      ipAddress: ipAddress,
      refreshToken: hashedRefreshToken,
      expiresAt: expiresAt,
    });
  }

  logger.info("User logged in", {
    email: user.email,
    userId: user._id,
    ip: req.ip,
  });

  const expiry = rememberMe
    ? process.env.REFRESH_TOKEN_EXPIRY_REMEMBER_ME
    : process.env.REFRESH_TOKEN_EXPIRY;
  const options = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: ms(expiry),
  };

  res
    .status(200)
    .cookie("accessToken", accessToken, options)
    .cookie("refreshToken", refreshToken, options)
    .json(new ApiResponse(200, "Logged in successfully", null));
});

const logoutUser = asyncHandler(async (req, res) => {
  const user = await User.findById(
    req.user._id,
  );

  const hashedRefreshToken = user.createHash(req.cookies?.refreshToken);

  await Session.deleteMany({ refreshToken: hashedRefreshToken });

  const options = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
  };

  return res
    .status(200)
    .clearCookie("accessToken", options)
    .clearCookie("refreshToken", options)
    .json(new ApiResponse(200, {}, "User logged out"));
});

const forgotPassword = asyncHandler(async (req, res) => {
  const { email } = handleZodError(validateEmail(req.body));

  const user = await User.findOne({ email });

  if (!user) {
    return res
      .status(200)
      .json(
        new ApiResponse(
          200,
          "If an account exists, a reset link has been sent to the email"
        )
      );
  }

  if (user.loginType !== "EMAIL_PASSWORD") {
    return res.status(200).json(
      new ApiResponse(
        200,
        {
          code: "OAUTH_USER",
        },
        "You signed up using Google. Please use Google Sign-In to access your account."
      )
    );
  }

  const { unHashedToken, hashedToken, tokenExpiry } =
    user.generateTemporaryToken();

  user.emailVerificationToken = hashedToken;
  user.emailVerificationExpiry = tokenExpiry;
  await user.save({ validateBeforeSave: false });

  await sendEmail({
    email: user?.email,
    subject: "Please verify your email",
    mailgenContent: emailVerificationMailgenContent(
      user.username,
      `${process.env.CLIENT_URL}/verify-email/${unHashedToken}`
    ),
  });

  logger.info("Password reset email sent", {
    email: user.email,
    userId: user._id,
    ip: req.ip,
  });

  res
    .status(200)
    .json(
      new ApiResponse(
        200,
        null,
        "If an account exists, a reset link has been sent to the email"
      )
    );
});

const resetPassword = asyncHandler(async (req, res) => {
  const { token } = req.params;
  const { password } = handleZodError(validateResetPassword(req.body));

  if (!token) {
    throw new ApiError(400, "Password reset token is missing");
  }

  const hashedToken = createHash(token);

  const user = await User.findOne({
    resetPasswordToken: hashedToken,
    resetPasswordExpiry: { $gt: new Date() },
  });

  if (!user) {
    throw new ApiError(410, "Reset link has expired or is invalid.");
  }

  const isSamePassword = await isPasswordCorrect(password, user.password);
  if (isSamePassword) {
    throw new ApiError(400, "Password must be different from old password");
  }

  await prisma.user.update({
    where: { id: user.id },
    data: {
      password: hashedPassword,
      resetPasswordToken: null,
      resetPasswordExpiry: null,
    },
  });

  await User.findByIdAndUpdate(
    user._id,
    {
      $set: {
        password,
        resetPasswordToken: null,
        resetPasswordExpiry: null,
      },
    },
    { new: true }
  );

  await Session.deleteMany({ userId: user._id });

  logger.info("Password reset successful", {
    email: user.email,
    userId: user._id,
    ip: req.ip,
  });

  res
    .status(200)
    .json(new ApiResponse(200, null, "Password reset successfully"));
});

const refreshAccessToken = asyncHandler(async (req, res) => {
  const incomingRefreshToken = req.cookies?.refreshToken;

  if (!incomingRefreshToken) {
    throw new ApiError(401, "Refresh token is missing");
  }

  let decodedToken;
  try {
    decodedToken = jwt.verify(
      incomingRefreshToken,
      process.env.REFRESH_TOKEN_SECRET
    );
  } catch (error) {
    throw new ApiError(401, "Invalid or expired refresh token");
  }

  const user = await User.findById(decodedToken?._id);
  if (!user) {
    throw new ApiError(401, "Invalid refresh token");
  }

  const incomingUserAgent = req.headers["user-agent"];
  const incomingIp = req.ip;

  if (user.userAgent !== incomingUserAgent || user.ipAddress !== incomingIp) {
    await Session.deleteOne({ id: user._id });

    throw new ApiError(401, "Session mismatch. Please log in again.");
  }

  const { accessToken, refreshToken: newRefreshToken } =
    await generateAccessAndRefreshTokens(user._id);

  const hashedRefreshToken = createHash(refreshToken);

  await Session.findByIdAndUpdate(user._id, {
    $set: {
      refreshToken: hashedRefreshToken,
    },
  });

  const options = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
  };

  logger.info("Access token refreshed");

  res
    .status(200)
    .cookie("accessToken", accessToken, options)
    .cookie("refreshToken", refreshToken, options)
    .json(new ApiResponse(200, null, "Access token refreshed successfully"));
});

const logoutAllSessions = asyncHandler(async (req, res) => {
  const { id } = req.user;
  const { refreshToken } = req.cookies;

  const user = await User.findById(req.user._id)

  const hashedRefreshToken = user.createHash(refreshToken);

  await Session.deleteMany({
    userId: id,
    refreshToken: { $ne: hashedRefreshToken },
  });

  logger.info("Logged out from all other sessions");

  res
    .status(200)
    .json(new ApiResponse(200, null, "Logged out from all other sessions"));
});

const getActiveSessions = asyncHandler(async (req, res) => {
  const { id: userId } = req.user;
  const currentRefreshToken = req.cookies.refreshToken;

  const user = await User.findById(userId).select("-password -emailVerificationToken -emailVerificationExpiry");

  const hashedRefreshToken = user.createHash(currentRefreshToken);

  const sessions = await Session.find({ userId })
    .select({
      _id: 1,
      ipAddress: 1,
      userAgent: 1,
      updatedAt: 1,
      expiresAt: 1,
      refreshToken: 1,
    })
    .sort({ createdAt: -1 });

  // Setting true flag to current session
  const setCurrentFlag = sessions.map((session) => ({
    ...session,
    current: session.refreshToken === hashedRefreshToken,
  }));

  const removeRefreshToken = setCurrentFlag.map(
    ({ refreshToken, ...rest }) => rest
  );
  const formattedSessions = await transformSessions(removeRefreshToken);

  res
    .status(200)
    .json(
      new ApiResponse(
        200,
        formattedSessions,
        "Fetched all active sessions successfully"
      )
    );
});

const logoutSpecificSession = asyncHandler(async (req, res) => {
  const { id } = req.user._id;
  const { sessionId } = req.params;

  if (!sessionId) {
    throw new CustomError(400, "Session ID is required");
  }

  const session = await Session.findById(sessionId);

  if (!session || session.userId !== id) {
    throw new CustomError(401, "Invalid session ID");
  }

  await Session.deleteOne({ id: sessionId });

  logger.info("User logged out of specific session");

  res
    .status(200)
    .json(
      new ApiResponse(200, null, "Logged out of specific session successfully")
    );
});

const googleLogin = asyncHandler(async (req, res) => {
  const { token, rememberMe } = req.body;
  const payload = await verifyGoogleToken(token);

  const { email, name, picture } = payload;

  if (!email || !name || !picture) {
    throw new CustomError(200, "");
  }

  const existingUser = await User.findOne({ email });

  let user = existingUser;

  // Creating new user
  if (!user) {
    user = await User.create({
      email,
      fullname: name,
      isVerified: true,
      avatar: picture,
      provider: "GOOGLE",
    });
  }

  // Creating a session for existing user
  const userAgent = req.headers["user-agent"];
  const ipAddress = req.ip;

  const existingSession = await Session.findOne({
    userId: user._id,
    userAgent,
    ipAddress,
  });

  const result = await Session.aggregate([
    { $match: { userId: user.id } },
    { $count: "total" },
  ]);

  const existingSessionsCount = result[0]?.total || 0;

  // Enforce session limit only if new session is being created
  if (!existingSession && existingSessionsCount >= process.env.MAX_SESSIONS) {
    throw new CustomError(
      429,
      "Maximum session limit reached. Please logout from another device first."
    );
  }

  const { accessToken, refreshToken } = await generateAccessAndRefreshTokens(
    user._id
  );

  const hashedRefreshToken = createHash(refreshToken);

  const expiresAt = new Date(Date.now() + ms(process.env.REFRESH_TOKEN_EXPIRY));

  if (existingSession) {
    // Update refreshToken + expiry for existing session

    await Session.updateOne(
      { _id: existingSession.id },
      {
        $set: {
          refreshToken: hashedRefreshToken,
          expiresAt: expiresAt,
        },
      }
    );
  } else {
    // Create new session
    await Session.create({
      userId: user.id,
      userAgent,
      ipAddress,
      refreshToken: hashedRefreshToken,
      expiresAt,
    });
  }

  logger.info(`${email} logged in via Google`);

  const options = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
  };

  res
    .status(200)
    .cookie("accessToken", accessToken, options)
    .cookie("refreshToken", refreshToken, options)
    .json(new ApiResponse(200, null, "Google login successful"));
});

const getProfile = asyncHandler(async (req, res) => {
  const { id } = req.user._id;

  const user = await User.findById(req.user._id);

  if (!user) {
    throw new ApiError(404, "User not found");
  }

  logger.info("User profile fetched", {
    email: user.email,
    userId: user._id,
    ip: req.ip,
  });

  res
    .status(200)
    .json(new ApiResponse(200, user, "User profile fetched successfully"));
});

export {
  register,
  verifyEmail,
  resendEmailVerification,
  login,
  logoutUser,
  logoutSpecificSession,
  googleLogin,
  getProfile,
  refreshAccessToken,
  logoutAllSessions,
  getActiveSessions,
  forgotPassword,
  resetPassword
};
